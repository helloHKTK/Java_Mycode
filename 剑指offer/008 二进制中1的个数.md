## 题目描述

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。例如，把9表示成二进制是1001，有2位是1。因此，如果输入是9，该函数输出为2。

### 1. 常规解法一：除2的思想，每次判断最低位是否为1（当输入的数是负数时，会陷入死循环）

```java
/* 牛客网未通过，提示：
运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。
*/
public int NumberOf1(int n) 
{
        int sum = 0;
        while (n!=0)
        {
            if ((n & 1) == 1) // n & 1 ：判断最低位是不是1
                sum++;
            n >>= 1; // 右移1位相当于/2

        }
        return sum;
 }
```



### 2.  常规解法二：乘2的思想(左移一位)，从低到高依次检查每一位是否为1

```java
/* 牛客网未通过，提示：
答案错误:您提交的程序没有通过所有的测试用例
case通过率为44.44%

用例:-2147483648
对应输出应该为:1
你的输出为:0
*/
int sum = 0;
int flag = 1; // 开始的时候将n与flag = 1做&与运算, 随后flag依次左移,再与n进行&运算,依次判断次低位是否为1
while (flag <= n)
{
	if ((n & flag) == flag)
		sum++;
	flag <<= 1; // 依次左移一位
}

return sum;
```



### 3. 巧妙的解法：【把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0】.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作

```
链接：https://www.nowcoder.com/questionTerminal/8ee967e43c2c4ec193b040ea7fbb10b8?answerType=1&f=discussion
来源：牛客网

举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，【把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0】.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。
```

```java
// 牛客网通过
public int NumberOf1(int n) {
        int sum = 0;
        while (n!=0)
        {
            sum++;
            n = (n - 1) & n;
        }
        return sum;
    }
```

